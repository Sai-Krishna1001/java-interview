
## 1. Java Components Overview
### Key Components for Compiling and Running Java Programs:
- **Java Development Kit (JDK):** Includes Java Runtime Environment (JRE) and essential tools like the Java compiler and Java command.
- **Java Runtime Environment (JRE):** Contains libraries and JVM necessary to run Java applications.
- **Java Virtual Machine (JVM):** Executes bytecode and ensures platform independence.
- **Just-In-Time (JIT) Compiler:** Optimizes bytecode translation for better performance.
- **Bytecode:** Compiled Java code, interpreted by JVM, making Java platform-independent.

### Execution Flow:
1. Java code is compiled into bytecode using the Java compiler.
2. The JVM interprets bytecode and translates it into machine code for the OS.
3. The JIT compiler optimizes bytecode execution.

## 2. Constructors in Java
### Definition and Characteristics:
- A **constructor** initializes object properties when an instance is created.
- It has the **same name as the class**.
- Unlike regular methods, constructors execute **only once at object creation**.

### Key Features:
- **Constructor Overloading:** Multiple constructors with different parameters.
- **Calling Another Constructor:** Use `this()` within the same class.
- **Calling Superclass Constructor:** Use `super()` to invoke the parent class constructor.

## 3. Abstract Class vs Interface
### Abstract Class:
- Can contain both **abstract methods (without body)** and **concrete methods**.
- Requires `abstract` keyword.
- A class can extend **only one** abstract class.

### Interface:
- Contains **only abstract methods** (before Java 8).
- A class can **implement multiple interfaces**.
- Uses `interface` keyword, and methods are implicitly `public abstract`.

## 4. Why Multiple Inheritance is Not Supported in Java
- If a class extends **two parent classes** with the same method, ambiguity arises.
- Leads to **diamond problem** (if a common ancestor has the same method).
- Java prevents multiple inheritance to avoid confusion and inconsistency.

## 5. Implementing Multiple Interfaces with the Same Method
- A class **can implement multiple interfaces** even if they have the same method signature.
- No ambiguity since the implementing class **provides its own method implementation**.
- Unlike multiple inheritance in classes, this does not lead to the **diamond problem**.

### Example:
```java
interface Car { void go(); }
interface Driverless { void go(); }
class Honda implements Car, Driverless {
    public void go() { System.out.println("Honda is moving"); }
}
```

